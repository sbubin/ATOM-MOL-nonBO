!DEC$ DECLARE

module misc

!Module misc contains some auxiliary mathematical routines
!taken from different sources.

use globvars

contains


function drnor() 
!This is David Kahaner's routine DRNOR rewritten by Sergiy 
!Bubin in Fortran 90. The original Fortran 77 code can be 
!found in NetLib.
!
!DRNOR() GENERATES NORMAL RANDOM NUMBERS, WITH MEAN ZERO AND
!UNIT STANDARD DEVIATION, OFTEN DENOTED N(0,1).
!
!USE
!    FIRST TIME....
!        Z = DRNOR_START(ISEED)
!                     
!    HERE ISEED IS ANY  N O N - Z E R O  INTEGER.
!    THIS CAUSES INITIALIZATION OF THE PROGRAM.
!    DRNOR_START RETURNS A DOUBLE PRECISION ECHO OF ISEED.
!
!    SUBSEQUENT TIMES...
!        Z = DRNOR()
!    CAUSES THE NEXT DOUBLE PRECISION RANDOM NUMBER
!    TO BE RETURNED AS Z.
!
!TYPICAL USAGE
!
!    DOUBLE PRECISION DSTART,DRNOR,Z
!    INTEGER ISEED,I
!    ISEED = 305
!    Z = DSTART(ISEED)
!    DO 1 I = 1,10
!       Z = DRNOR()
!       WRITE(*,'(1X,D20.15)') Z
! 1  CONTINUE 
!    END
real(8)  DRNOR,DRNOR_START
real(8)  AA,B,C,C1,C2,PC,X,Y,XN
real(8)  V(65),DSTART,U(17),S,T,UN,VNI
integer  J,IA,IB,IC,II,JJ,ID,III,JJJ,L
save     U,II,JJ
integer  ISEED

data AA,B,C &
/0.123758602991705622657860318807D+02, &
0.487899177760378968003825536710D+00,  &
0.126770580788654778410032042685D+02/

data C1,C2,PC,XN &
/0.9689279D0,1.301198D0,              &
0.195830333955546914251231662871D-01, &
0.277699426966287548981739308903D+01/

data (V(L), L=1,18) &
/0.340945028703977890881422029377D+00, &
0.457314591866933536170242641762D+00, &
0.539779281611666939596931167481D+00, &
0.606242679653048904661174385559D+00, &
0.663169062764524854743428299352D+00, &
0.713697459056025891183276150202D+00, &
0.759612474933920604605610034675D+00, &
0.802035600355531312751497342081D+00, &
0.841722667978955421276418428136D+00, &
0.879210223208313639290346470191D+00, &
0.914894804386750587541168254518D+00, &
0.949079113753090250631877133376D+00, &
0.982000481239888200218207508382D+00, &
0.101384923802994173461911276018D+01, &
0.104478103674017351825847605485D+01, &
0.107492538202855351339149779813D+01, &
0.110439170226812581109973656162D+01, &
0.113327377624394079212251428682D+01/
data (V(L), L=19,37) &
/0.116165303013393172842858957666D+01, &
0.118960104083873798956793871425D+01, &
0.121718147070087121538258873613D+01, &
0.124445158789824683238161436879D+01, &
0.127146348057211969375402099579D+01, &
0.129826504188319751190626947962D+01, &
0.132490078218086109537654808436D+01, &
0.135141250993337129690631764473D+01, &
0.137783991287001181384096757263D+01, &
0.140422106355997540689484486002D+01, &
0.143059286850269131403410180874D+01, &
0.145699147613767157824869156623D+01, &
0.148345265660321931119703498108D+01, &
0.151001216431851991531882612256D+01, &
0.153670609335952099134607533122D+01, &
0.156357123503769104042967185962D+01, &
0.159064544701425352365935513885D+01, &
0.161796804367444698360816323707D+01, &
0.164558021836908161542865488149D+01/
data (V(L), L=38,55) &
/0.167352550956703867146009214486D+01, &
0.170185032506274055254533570699D+01, &
0.173060454131778319060975251429D+01, &
0.175984219903830120010946138955D+01, &
0.178962232156657450014351836107D+01, &
0.182000989013069176863519209140D+01, &
0.185107702023027589942628767312D+01, &
0.188290439759287281399927405628D+01, &
0.191558305194303202395065401364D+01, &
0.194921657491636060191700129156D+01, &
0.198392392890568577258506733664D+01, &
0.201984305290623555306662745946D+01, &
0.205713555999009616804474181513D+01, &
0.209599295624939161758467989658D+01, &
0.213664502254438986524966622832D+01, &
0.217937134039813565892460111431D+01, &
0.222451750721601784110056845259D+01, &
0.227251855485014779874266158018D+01/
data (V(L), L=56,65) &
/0.232393382009430256940425938218D+01, &
0.237950077408282829688673722776D+01, &
0.244022179797994340264326423618D+01, &
0.250751170186531701106382130475D+01, &
0.258346583522542956831304962942D+01, &
0.267139159032083601869533973173D+01, &
0.277699426966286466722522163764D+01, &
0.277699426966286466722522163764D+01, &
0.277699426966286466722522163764D+01, &
0.277699426966286466722522163764D+01/
!LOAD DATA ARRAY IN CASE USER FORGETS TO INITIALIZE.
!THIS ARRAY IS THE RESULT OF CALLING DUNI 100000 TIMES
!WITH SEED 305.
data U &
/0.471960981577884755837789724978D+00, &
0.930323453205669578433639632431D+00, &
0.110161790933730836587127944899D+00, &
0.571501996273139518362638757010D-01, &
0.402467554779738266237538503137D+00, &
0.451181953427459489458279456915D+00, &
0.296076152342721102174129954053D+00, &
0.128202189325888116466879622359D-01, &
0.314274693850973603980853259266D+00, &
0.335521366752294932468163594171D-02, &
0.488685045200439371607850367840D+00, &
0.195470426865656758693860613516D+00, &
0.864162706791773556901599326053D+00, &
0.335505955815259203596381170316D+00, &
0.377190200199058085469526470541D+00, &
0.400780392114818314671676525916D+00, &
0.374224214182207466262750307281D+00/

data II,JJ /17,5/
!***FIRST EXECUTABLE STATEMENT  DRNOR

! FAST PART...

!BASIC GENERATOR IS FIBONACCI
UN = U(II)-U(JJ)
if (UN.LT.0.0D0) UN = UN+1.
U(II) = UN
!U(II) AND UN ARE UNIFORM ON [0,1)
!VNI IS UNIFORM ON [-1,1)
VNI = UN + UN -1.
II = II-1
if (II.EQ.0)II = 17
JJ = JJ-1
if (JJ.EQ.0)JJ = 17
!INT(UN(II)*128) IN RANGE [0,127],  J IS IN RANGE [1,64]
J = mod(int(U(II)*128),64)+1
!PICK SIGN AS VNI IS POSITIVE OR NEGATIVE 
DRNOR = VNI*V(J+1)
if (abs(DRNOR).LE.V(J)) return

! SLOW PART; AA IS A*F(0)

X = (abs(DRNOR)-V(J))/(V(J+1)-V(J))
!Y IS UNIFORM ON [0,1)
Y = U(II)-U(JJ)
if (Y.LT.0.0D0) Y = Y+1. 
U(II) = Y
II = II-1
if (II.EQ.0) II = 17
JJ = JJ-1
if (JJ.EQ.0) JJ = 17

S = X+Y
if (S.GT.C2) then 
  DRNOR = sign(B-B*X,DRNOR)
  return
endif
if (S.LE.C1) return
if (Y.GT.C-AA*exp(-.5D0*(B-B*X)**2)) then 
  DRNOR = sign(B-B*X,DRNOR)
  return
endif
if (exp(-.5D0*V(J+1)**2)+Y*PC/V(J+1).LE.exp(-.5D0*DRNOR**2)) return

!TAIL PART; .36010157... IS 1.0D0/XN
!Y IS UNIFORM ON [0,1) 
2222 Y = U(II)-U(JJ)
if (Y.LE.0.0D0) Y = Y+1. 
U(II) = Y
II = II-1
if (II.EQ.0)II = 17
JJ = JJ-1
if (JJ.EQ.0)JJ = 17

X = 0.360101571301190680192994239651D+00*log(Y)
!Y IS UNIFORM ON [0,1) 
Y = U(II)-U(JJ)
if (Y.LE.0.0D0) Y = Y+1. 
U(II) = Y
II = II-1
if (II.EQ.0)II = 17
JJ = JJ-1
if (JJ.EQ.0)JJ = 17
if ( -2.0D0*log(Y).LE.X**2 ) goto 2222
DRNOR = sign(XN-X,DRNOR)
return

!FILL
entry DRNOR_START(ISEED)
if (ISEED.NE.0) then

  !SET UP ...
  !GENERATE RANDOM BIT PATTERN IN ARRAY BASED ON GIVEN SEED

  II = 17
  JJ = 5
  IA = mod(abs(ISEED),32707)
  IB = 1111
  IC = 1947
  do III = 1,17
    S = 0.0D0 
    T = 0.5D0 
    !DO FOR EACH OF THE BITS OF MANTISSA OF WORD
    !LOOP  OVER 95 BITS, ENOUGH FOR MOST MACHINES
    !IN DOUBLE PRECISION.
    do JJJ = 1,95
      ID = IC-IA
      if (ID.LT.0) then
        ID = ID+32707
        S = S+T
      endif
      IA = IB
      IB = IC
      IC = ID
      T = 0.5D0*T
	enddo
    U(III) = S
  enddo
endif
!RETURN FLOATING ECHO OF ISEED
DRNOR_START=dfloat(ISEED)
return

end function drnor



subroutine DA17LSM(F,XGUESS,STEP,EPS,MAXFNEVAL,ACTFNEVAL,XMIN,FMIN)
!This is modified subroutine A17LS by J.S.Nash. I slightly 
!simplified it, added some formal parameters and excluded 
!others, changed single precision to double and translated 
!the code from F77 to F90 free (Sergiy Bubin) 
!
!Algorithm 17 success-failure linear search with parabolic
!inverse interpolation, J.C.Nash, February 1980.

!F         - User supplied function.
!            Calling sequence is Fval=F(x). x must not be 
!            changed by F.
!XGUESS    - Initial guess to minimum of the function.
!STEP      - Initial step size. First two function 
!            evaluations are carried out at points 
!            XGUESS and XGUESS+STEP.
!EPS       - Required accuracy of minimum point of F. If 
!            EPS is smaller than maximal accuracy that can 
!            be achieved, procedure finds the minimum with 
!            this maximal accuracy.
!MAXFNEVAL - Maximal number of function evaluations allowed.
!            If this number is exceeded then the subroutine
!            does not generate an error. The best found 
!            value is returned as minimum point of F.
!ACTFNEVAL - Actual number of function evaluations.
!XMIN      - The point of minimum found.
!FMIN      - Function value at the minimum point.
 
!Arguments:
real(dprec)    F,XGUESS,STEP,EPS,XMIN,FMIN
integer    MAXFNEVAL,ACTFNEVAL
!Local variables:
real(dprec)    A1,A2,P,S1,S0,X0,X2,XPRED,BIG,X1

    XMIN=XGUESS
	BIG=huge(S0) 
    ACTFNEVAL=0
!  STEP CHANGE FACTORS
    A1=ONE+ONEHALF
    A2=-ONEFOURTH
!  STEP 1 
    IF(ACTFNEVAL>=MAXFNEVAL)GOTO 220 
    ACTFNEVAL=ACTFNEVAL+1
    P=F(XMIN)
!  STEP 2 
20  S1=P
    S0=-BIG
    X1=ZERO
    XPRED=XMIN
!  STEP 3 
30  X2=X1+STEP
    XMIN=XPRED+X2
!  STEP 4 
    !Cycle until achieving either EPS precision or maximal 
	!possible precision if EPS is too small
	IF ((abs(XMIN-XPRED)<=EPS).OR.(XMIN==XPRED+X1)) GOTO 220
!  STEP 5 
    IF(ACTFNEVAL>=MAXFNEVAL)GOTO 220  
    ACTFNEVAL=ACTFNEVAL+1
    P=F(XMIN)
!  STEP 6 
    IF(P<S1)GOTO 100
!  STEP 7 
    IF(S0>=S1)GOTO 110
!  STEP 8 
    S0=P
    X0=X2
!  STEP 9 
    STEP=A2*STEP
    GOTO 30
!  STEP 10
100 X0=X1
    S0=S1
    X1=X2
    S1=P
    STEP=A1*STEP
    GOTO 30
!  STEP 11
110 X0=X0-X1
    S0=(S0-S1)*STEP 
    P=(P-S1)*X0
!  STEP 12
    IF(P==S0)GOTO 180
!  STEP 13
    STEP=ONEHALF*(P*X0-S0*STEP)/(P-S0)
!  STEP 14
    X2=X1+STEP
    XMIN=XPRED+X2
!  STEP 15
    IF(XMIN==XPRED+X1)GOTO 200
!  STEP 16
    IF(ACTFNEVAL>=MAXFNEVAL)GOTO 220 
    ACTFNEVAL=ACTFNEVAL+1
    P=F(XMIN)
!  STEP 17
    IF(P<S1)GOTO 190
!  STEP 18
180 XMIN=XPRED+X1
    P=S1
    GOTO 200
!  STEP 19
190 X1=X2
!  STEP 20
200 STEP=A2*STEP
    GOTO 20
220 XMIN=XPRED
    FMIN=S1

end subroutine DA17LSM 



subroutine DFMINM(F,A,B,T,X,FMIN)
!This is slightly changed function DFMIN taken from PORT. 
!I made it a subroutine (not a function), translated the 
!code from F77 to F90, and replaced D1MACH(1) and 
!D1MACH(4) calls with TINY(X) and EPSILON(X) respectively.
!  Input and output parameters:
!F         - User supplied function.
!            Calling sequence is Fval=F(x). x must not be 
!            changed by F.
!A,B       - The interval at which F attains its minimum.
!T         - Determines a tolerance of TOL=EPSILON(X)*DABS(X)+T
!            and F is never evaluated at two points closer
!            together than TOL. Actually I found out that the
!            DFMIN does not reach this tolerance. One needs to
!            set TOL twice as small as desired tolerance to be 
!            sure about accuracy. 
!X         - Minimum point.
!FMIN      - Function value at the minimum point.           
!
!  DFMIN FINDS AN APPROXIMATION X TO THE POINT IN
!  THE INTERVAL (A,B) AT WHICH F ATTAINS ITS MINIMUM,
!  AND RETURNS IN DFMIN THE VALUE OF F AT X.
!
!  T DETERMINES A TOLERANCE OF
!
!              TOL  =  EPSILON(X) * DABS(X) + T
!
!  AND F IS NEVER EVALUATED AT TWO POINTS CLOSER
!  TOGETHER THAN TOL.
!
!  IF T IS INPUT .LE. ZERO, IT IS SET TO 10.*TINY(X)
!
!  THE METHOD USED IS A COMBINATION OF GOLDEN SEARCH
!  AND SUCCESSIVE PARABOLIC INTERPOLATION.
!  CONVERGENCE IS NEVER MUCH SLOWER THAN FOR A
!  FIBONACCI SEARCH.
!  IF F HAS A CONTINUOUS SECOND DERIVATIVE WHICH IS POSITIVE
!  AT THE MINIMUM ( NOT AT A OR B) THEN, IGNORING
!  ROUNDING ERRORS, CONVERGENCE IS SUPERLINEAR,
!  AND USUALLY THE ORDER IS AT LEAST 1.3247....
!
!  THIS IS BRENT'S ALGORITHM - SEE PAGE 188 OF HIS BOOK.
!
!  A, STORED IN SA, AND B, STORED IN SB ARE
!  AT ANY STEP THE CURRENT BOUNDARIES FOR
!  THE INTERVAL CONTAINING THE MINIMUM.
!
!  X IS THE POINT AT WHICH F HAS THE LEAST VALUE
!  SO FAR, (OR THE POINT OF MOST RECENT EVALUATION
!  IF THERE IS A TIE).
!
!  W IS THE POINT WITH THE NEXT LOWEST VALUE OF F
!
!  V IS THE PREVIOUS VALUE OF W
!
! U IS THE LAST POINT AT WHICH F HAS BEEN EVALUATED
!  (U IS UNDEFINED THE FIRST TIME.)

!Arguments:
      real(dprec) F,A,B,T,X,FMIN
!Local variables:
      real(dprec) SA,SB,D,E,M,P,Q,R
      real(dprec) TOL,T2,TT,U,V,W,FU,FV,FW,FX,CONS
    
      TT = T
      IF (T .LE. ZERO ) TT = TEN*tiny(X)
      IF (A .LT. B) GO TO 5
      SA = B
      SB = A
      GO TO 8
    5 SA = A
      SB = B
    8 CONS = ONEHALF*(THREE-sqrt(FIVE))
!
! ARBITRARILY FOR THE FIRST STEP CHOOSE
!
!    X = A + .5(3-DSQRT(5))* (B-A)
!
      X = SA + CONS*(SB - SA)
      W = X
      V = W
      E = ZERO
      FX = F(X)
      FW = FX
      FV = FW
!
! THE MAIN LOOP STARTS HERE.
!
   10 M = ONEHALF*(SA + SB)
      TOL = epsilon(X) * abs(X) + TT
      T2 = TWO * TOL
!
! CHECK THE STOPPING CRITERION:
!       (M = MIDPOINT)
! IF DABS(X-M) .LE. (2*TOL - .5(B-A)),
! I.E. IF MAX(X-A, B-X) .LE. 2*TOL, THEN
! THE PROCEDURE TERMINATES WITH X AS THE
! APPROXIMATE POSITION OF THE MINIMUM.
!C
      IF (abs(X-M) .LE. T2-ONEHALF*(SB-SA)) GO TO 190
      R = ZERO
      Q = R
      P = Q
      IF (abs(E) .LE. TOL) GO TO 40
!
!    FIT THE PARABOLA
!
!    Q = 2((X-V)(FX-FW) - (X-W)(FX-FV))
!    P = ((X-V)**2)(FX-FW) - ((X-W))**2)(FX-FV)
!
      R = (X-W)*(FX-FV)
      Q = (X-V)*(FX-FW)
      P = (X-V)*Q - (X-W) * R
      Q = TWO*(Q-R)
      IF (Q .LE. ZERO) GO TO 20
      P = -P
      GO TO 30
!
   20 Q = -Q
   30 R = E
      E = D
!
!  HERE E IS THE VALUE OF P/Q AT THE SECOND LAST
!  CYCLE; IF DABS(E) .LE. TOL, OR IF Q = 0.0.
!  OR IF X+P/Q LIES OUTSIDE OF (A,B), OR
!  DABS(P/Q) .GE. .5E, THEN A "GOLDEN
!  SECTION" STEP IS PERFORMED (AT 60 BELOW).
!
!  OTHERWISE A PARABOLIC INTERPOLATION
!  STEP IS TAKEN
!
   40 IF (abs(P).GE.abs(ONEHALF*Q*R)) GO TO 60
      IF ((P.LE.Q*(SA-X)).OR.(P.GE.Q*(SB-X))) GO TO 60
      D = P/Q
      U = X + D
!
!  EXCEPT F MUST NOT BE EVALUATED TOO CLOSE TO A OR B.
!
!  IF THE NEW POINT IS TOO CLOSE JUST PUT
!       D = +TOL   IF X.LT.M
!       D = -TOL   IF X.GE.M
!
      IF((U-SA.GE.T2).AND.(SB-U.GE.T2)) GO TO 90
      IF (X.GE.M) GO TO 50
      D = TOL
      GO TO 90
   50 D = -TOL
      GO TO 90
!
!  THIS IS THE "GOLDEN SECTION" STEP:
!
!       U = .5(SQRT(5)-1)X + .5(3-SQRT(5)A   IF X.GE.M
!       U = .5(SQRT(5)-1)X + .5(3-SQRT(5)B   IF X.LT.M
!
   60 IF (X.GE.M) GO TO 70
      E = SB - X
      GO TO 80
   70 E = SA - X
   80 D = CONS*E
!
!     U = X+(IF DABS(D).GE.TOL THEN D,
!          ELSE IF D.GT.0 THEN TOL     ELSE  -TOL)
!
   90 IF (abs(D).LT.TOL) GO TO 100
      U = X + D
      GO TO 120
  100 IF (D.LE.ZERO) GO TO 110
      U = X + TOL
      GO TO 120
  110 U = X - TOL
!
!  UPDATE EVERYTHING
!  IF FU.LE.FX THEN
!     BEGIN IF U.LT.X THEN B = X ELSE A = X
!     V = W;FV = FW;W = X;FW = FX;X = U;FX = FU
!     END
!  ELSE
!     BEGIN IF U.LT.X THEN A = U ELSE B = U
!     IF FU.LE.FW OR W = X THEN
!          BEGIN V = W;FV = FW;W = X;FW = FU END
!     ELSE IF FU.LE.FV OR V = X OR V = W THEN
!            BEGIN V = U; FV = FU
!            END
!     END
!
  120 FU = F(U)
      IF (FU.GT.FX) GO TO 150
      IF (U.GE.X) GO TO 130
      SB = X
      GO TO 140
  130 SA = X
  140 V = W
      FV = FW
      W = X
      FW = FX
      X = U
      FX = FU
      GO TO 10
!
  150 IF (U.GE.X) GO TO 160
      SA = U
      GO TO 170
  160 SB = U
  170 IF ((FU.GT.FW) .AND.(W.NE.X)) GO TO 180
      V = W
      FV = FW
      W = U
      FW = FU
      GO TO 10
!
  180 IF ((FU.GT.FV).AND.(V.NE.X).AND.(V.NE.W)) GO TO 10
      V = U
      FV = FU
      GO TO 10
!
  190 FMIN = FX
end subroutine DFMINM


end module misc
